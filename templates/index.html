<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deck Builder</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 720px;
            margin: 0 auto;
            padding: 24px;
            background: #f7f7f7;
        }
        h1 {
            text-align: center;
        }
        form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            background: #fff;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
        }
        form > div {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 4px;
        }
        input, select {
            padding: 8px;
        }
        button {
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }
        .secondary {
            background-color: #2d7dd2;
        }
        #result {
            margin-top: 20px;
            padding: 12px;
            background: #fff;
            border-radius: 8px;
            white-space: pre-wrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
        }
    </style>
</head>
<body>
    <h1>Deck Builder</h1>
    <form id="deckForm" enctype="multipart/form-data">
        <div>
            <label for="commander">Commander</label>
            <input type="text" id="commander" name="commander" placeholder="e.g. Lord of the Nazgul" required>
        </div>
        <div>
            <label for="partner">Partner (optional)</label>
            <input type="text" id="partner" name="partner" placeholder="Partner name">
        </div>
        <div>
            <label for="theme">Theme (optional)</label>
            <input type="text" id="theme" name="theme" placeholder="e.g. zombies">
        </div>
        <div>
            <label for="budget">Budget</label>
            <select id="budget" name="budget">
                <option value="REGULAR">Regular</option>
                <option value="BUDGET">Budget</option>
                <option value="EXPANSIVE">Expansive</option>
            </select>
        </div>
        <div>
            <label for="inventory">Inventory CSV</label>
            <input type="file" id="inventory" name="inventory" accept=".csv" required>
        </div>
        <div>
            <label for="edhrec_data">EDHRec data (JSON fetched in browser)</label>
            <textarea id="edhrec_data" name="edhrec_data" rows="10" placeholder='{"avg_deck": {"Card": 2}, "card_details": {...}}'></textarea>
            <small id="edhrec_status" style="color:#555;"></small>
        </div>
        <div style="display:flex; gap:8px; align-items:flex-end;">
            <button type="button" class="secondary" id="fetchEdhrecBtn">Fetch EDHRec data</button>
            <button type="submit">Build Deck</button>
        </div>
    </form>

    <div id="result"></div>

    <script>
        const form = document.getElementById('deckForm');
        const resultDiv = document.getElementById('result');
        const fetchBtn = document.getElementById('fetchEdhrecBtn');
        const edhrecTextarea = document.getElementById('edhrec_data');
        const edhrecStatus = document.getElementById('edhrec_status');

        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        const slugify = (str) =>
            str
                .toLowerCase()
                .replace(/[^a-z0-9\s/-]/g, '')
                .trim()
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-');

        const fetchJson = async (url) => {
            const res = await fetch(url, { credentials: 'omit' });
            if (!res.ok) throw new Error(`Request failed ${res.status}: ${url}`);
            return res.json();
        };

        const parseDeckFromList = (list) => {
            const deck = {};
            if (!Array.isArray(list)) return deck;
            for (const line of list) {
                const parts = String(line).trim().split(' ');
                if (!parts[0] || isNaN(Number(parts[0]))) continue;
                const qty = Number(parts.shift());
                const name = parts.join(' ');
                if (name) deck[name] = qty;
            }
            return deck;
        };

        const buildCardDetails = (cardlists) => {
            const cardDetails = {};
            const topByType = {};
            if (!Array.isArray(cardlists)) return { cardDetails, topByType };

            for (const group of cardlists) {
                const cards = group.cards || [];
                for (const card of cards) {
                    const name = card.name;
                    const primary_type = (card.types && card.types[0]) || card.primary_type || card.type || 'Unknown';
                    cardDetails[name] = {
                        name,
                        primary_type,
                        type: card.type || primary_type,
                        color_identity: card.color_identity || card.colorIdentity || [],
                    };
                    if (!topByType[primary_type]) topByType[primary_type] = [];
                    topByType[primary_type].push({
                        name,
                        primary_type,
                        color_identity: cardDetails[name].color_identity,
                    });
                }
            }

            // sort each type list by EDHRec rank if present
            Object.values(topByType).forEach((arr) => arr.sort((a, b) => (a.rank || 0) - (b.rank || 0)));
            return { cardDetails, topByType };
        };

        const buildCardList = (cardDetails) => {
            const cards = {};
            Object.entries(cardDetails).forEach(([name, detail]) => {
                cards[name] = { primary_type: detail.primary_type, type: detail.type, color_identity: detail.color_identity };
            });
            return { cards };
        };

        const fetchEdhrecData = async () => {
            const commander = document.getElementById('commander').value.trim();
            const theme = document.getElementById('theme').value.trim();
            const budget = document.getElementById('budget').value;
            if (!commander) {
                edhrecStatus.textContent = 'Commander is required to fetch EDHRec data.';
                return;
            }

            const commanderSlug = slugify(commander);
            const themeSlug = theme ? slugify(theme) : null;
            const budgetParam = budget && budget !== 'REGULAR' ? `?budget=${budget.toLowerCase()}` : '';

            const commanderUrl = `https://json.edhrec.com/pages/commanders/${commanderSlug}${themeSlug ? '/' + themeSlug : ''}.json${budgetParam}`;
            const avgDeckUrl = `https://json.edhrec.com/pages/average-decks/${commanderSlug}${themeSlug ? '/' + themeSlug : ''}.json${budgetParam}`;

            edhrecStatus.textContent = 'Fetching EDHRec data...';
            resultDiv.textContent = '';

            try {
                const [commanderJson, avgJson] = await Promise.all([
                    fetchJson(commanderUrl),
                    fetchJson(avgDeckUrl),
                ]);

                const avgDeck = parseDeckFromList(avgJson?.deck || avgJson?.panels?.[0]?.contents || []);
                const { cardDetails, topByType } = buildCardDetails(commanderJson?.cardlists || []);
                const cardList = buildCardList(cardDetails);

                const payload = {
                    avg_deck: avgDeck,
                    card_details: cardDetails,
                    card_list: cardList,
                    top_cards_by_type: topByType,
                    similar: {}, // similar lookups are skipped to avoid extra requests; backend will skip if empty
                };

                edhrecTextarea.value = JSON.stringify(payload, null, 2);
                edhrecStatus.textContent = 'EDHRec data fetched. Review and submit.';
            } catch (err) {
                edhrecStatus.textContent = `Failed to fetch EDHRec data: ${err.message}`;
            }
        };

        fetchBtn.addEventListener('click', fetchEdhrecData);

        async function postJson(url, body) {
            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.json();
        }

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            resultDiv.textContent = '';

            const edhrecText = edhrecTextarea.value.trim();
            let parsedEdhrec = null;
            if (edhrecText) {
                try {
                    parsedEdhrec = JSON.parse(edhrecText);
                } catch (err) {
                    resultDiv.textContent = `Invalid EDHRec JSON: ${err.message}`;
                    return;
                }
            }

            const formData = new FormData(e.target);
            if (parsedEdhrec) formData.set('edhrec_data', JSON.stringify(parsedEdhrec));

            resultDiv.textContent = 'Starting build...';

            try {
                const startRes = await fetch('/start', { method: 'POST', body: formData });
                const startJson = await startRes.json();
                if (!startRes.ok) {
                    resultDiv.textContent = `Error starting build: ${startJson.error || startJson}`;
                    return;
                }

                const buildId = startJson.build_id;
                resultDiv.textContent = `Build started (id=${buildId}). Listening for progress...`;

                const es = new EventSource(`/events?build_id=${buildId}`);

                es.addEventListener('progress', (ev) => {
                    const data = JSON.parse(ev.data);
                    resultDiv.textContent = data.message;
                });

                es.addEventListener('request', async (ev) => {
                    const data = JSON.parse(ev.data);
                    const missingRaw = data.missing_key || '';
                    resultDiv.textContent = `Server requested missing data: ${missingRaw}. Fetching from EDHRec...`;

                    // Try to extract a quoted token like 'card_details' or a card name from the server message.
                    const quoted = (missingRaw.match(/'([^']+)'/) || [])[1];
                    // If the server asked specifically for a card's details, the message format is: "Missing card details for 'Card Name' in provided EDHRec payload"
                    const isCardDetailsMsg = /Missing card details for/.test(missingRaw) && quoted;

                    try {
                        if (isCardDetailsMsg) {
                            const cardName = quoted;
                            const cardSlug = slugify(cardName);
                            const cardUrl = `https://json.edhrec.com/pages/cards/${cardSlug}.json`;
                            try {
                                const cardJson = await fetchJson(cardUrl);
                                // cardJson shape varies; try common places for similar and card info
                                const cardData = cardJson || {};
                                // Build card_details entry
                                const primary_type = cardData.primary_type || (cardData.types && cardData.types[0]) || cardData.type || (cardData.card && (cardData.card.type || cardData.card.primary_type)) || 'Unknown';
                                const type = cardData.type || primary_type;
                                const color_identity = cardData.color_identity || cardData.colorIdentity || (cardData.card && cardData.card.color_identity) || [];
                                const cardDetailsEntry = {};
                                cardDetailsEntry[cardName] = {
                                    name: cardName,
                                    primary_type: primary_type,
                                    type: type,
                                    color_identity: color_identity,
                                };

                                // Try to extract similar list
                                let similarList = [];
                                if (Array.isArray(cardData.similar)) {
                                    similarList = cardData.similar;
                                } else if (cardData.data && Array.isArray(cardData.data.similar)) {
                                    similarList = cardData.data.similar;
                                } else if (cardData.similar_cards && Array.isArray(cardData.similar_cards)) {
                                    similarList = cardData.similar_cards;
                                }

                                // Normalize similar entries to {name, color_identity}
                                const similarNormalized = {};
                                similarNormalized[cardName] = (similarList || []).map((c) => {
                                    if (typeof c === 'string') return { name: c, color_identity: [] };
                                    return {
                                        name: c.name || c.cardName || c.title || '',
                                        color_identity: c.color_identity || c.colorIdentity || c.colorIdentity || [],
                                    };
                                }).filter(Boolean);

                                const toSend = {
                                    card_details: cardDetailsEntry,
                                    similar: similarNormalized,
                                };

                                await postJson('/update', { build_id: buildId, edhrec_payload: toSend });
                                resultDiv.textContent = `Posted card details and similar for ${cardName} to server.`;
                                return;
                            } catch (err) {
                                // If fetching specific card failed, fall through to sending whatever payload we have
                                console.warn('Failed to fetch card JSON', err);
                            }
                        }

                        // Fallback: ensure we have commander-level payload and send the requested key if present, otherwise send full payload
                        await fetchEdhrecData();
                        const payloadText = document.getElementById('edhrec_data').value;
                        const payload = payloadText ? JSON.parse(payloadText) : {};
                        const toSend = {};
                        // Try to map the missingRaw to a simple key (e.g., 'avg_deck', 'card_list', 'top_cards_by_type', 'similar', 'card_details')
                        const simpleKey = quoted || (['avg_deck','card_list','top_cards_by_type','similar','card_details'].find(k => missingRaw.toLowerCase().includes(k)));
                        if (simpleKey && payload[simpleKey]) {
                            toSend[simpleKey] = payload[simpleKey];
                        } else {
                            // send entire payload as a fallback
                            Object.assign(toSend, payload);
                        }

                        await postJson('/update', { build_id: buildId, edhrec_payload: toSend });
                        resultDiv.textContent = `Posted missing data to server. Continuing...`;
                    } catch (err) {
                        resultDiv.textContent = `Failed to fetch/send missing data: ${err.message}`;
                    }
                 });

                es.addEventListener('result', (ev) => {
                    const data = JSON.parse(ev.data).result;
                    const deck = data.deck || {};
                    const deckSize = data.deck_size ?? Object.values(deck).reduce((acc, val) => acc + (parseInt(val, 10) || 0), 0);
                    const deckLines = Object.entries(deck)
                        .sort(([aName], [bName]) => aName.localeCompare(bName))
                        .map(([name, count]) => `${count} ${name}`)
                        .join('\n');

                    const missing = (data.unavailable_cards || []).join(', ');
                    resultDiv.textContent =
`Deck (${deckSize} cards)\n${deckLines}\n\nUnavailable cards: ${missing || 'None ðŸŽ‰'}`;
                    es.close();
                });

                es.addEventListener('error', (ev) => {
                    // generic error
                    try {
                        const err = JSON.parse(ev.data || '{}');
                        if (err.message) resultDiv.textContent = `Error: ${err.message}`;
                    } catch (_e) {
                        // ignore
                    }
                });

            } catch (error) {
                resultDiv.textContent = `Error starting build: ${error.message}`;
            }
        });
    </script>
</body>
</html>